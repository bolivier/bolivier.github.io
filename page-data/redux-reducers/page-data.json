{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/redux-reducers/","result":{"data":{"site":{"siteMetadata":{"title":"Brandon Olivier","social":[{"name":"GitHub","url":"https://github.com/bolivier"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"782d36cf-e69a-5f9c-835d-4bf5d513d046","excerpt":"edit: at this point, I'd reccomend  the redux starter kit The Problem I end up writing a lot of Redux code and one of the things thatâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reducing Boilerplate in Redux\",\n  \"date\": \"2018-09-12T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"edit: at this point, I\\u2019d reccomend \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://redux-starter-kit.js.org/\"\n  }), \"the redux starter kit\")), mdx(\"h2\", {\n    \"id\": \"the-problem\"\n  }, \"The Problem\"), mdx(\"p\", null, \"I end up writing a lot of Redux code and one of the things that\\nirritates me most is writing code that\\u2019s so very nearly identical for\\ntop level items in the application state.\"), mdx(\"p\", null, \"To quickly recap, reducers are pure functions that take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"action\"), \" as arguments. Based on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \" property of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"action\"), \",\\nit makes a change to the state and returns a new copy of it. You can\\nread more about Redux at \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the Redux docs\"), \".\"), mdx(\"p\", null, \"I might write something like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"export const todoReducer = (state, action) => {\\n  switch(action.type) {\\n    case ADD_TODO:\\n      return {\\n        ...state,\\n        todos: {...state.todos, [action.payload.id]: ...action.payload},\\n      };\\n    default:\\n      return state;\\n  }\\n};\\n\")), mdx(\"p\", null, \"to add a new todo to a todo application.\"), mdx(\"p\", null, \"My issue with this code is that I\\u2019m going to duplicate the same adding\\nlogic for all my reducers with \\u201Cadd\\u201D behavior. I don\\u2019t think it\\u2019s so\\nmuch bad practice as irritating to lazy programmers like me who don\\u2019t\\nwant to type all that.\"), mdx(\"h2\", {\n    \"id\": \"my-solution\"\n  }, \"My solution\"), mdx(\"p\", null, \"What I would really like is something where I could specify a generic\\naddition function and use it across reducers. The syntax I imagine for\\nsomething like that is\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"// prefix -> initialState, [reducerGenerics] -> reducer\\nexport const todoReducer = createReducer('todo', {}, ['add']);\\n\")), mdx(\"p\", null, \"I need a prefix to identify all these actions, because action types need\\nto be unique. I can prefix add like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"todos/ADD\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"todos\"), \" is\\ngenerated dynamically. I\\u2019ll need to know initialState so I can return\\nthat when there isn\\u2019t a state passed in. And then I want to pass an\\narray with names I can use to look up which generic reducer function to\\nuse and not repeat myself. Since those probably aren\\u2019t going to cover\\nall my use cases, I\\u2019ll go ahead and pass a regular reducer function\\nthat will take precedence over the custom ones.\"), mdx(\"p\", null, \"The code for something like that might look like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"export function createReducer(prefix, initialState, reducerGenerics, customReductions) {\\n  return (state, action) => {\\n    if (!state) {\\n      return initialState;\\n    }\\n\\n    const customAlteredState = applyCustomReductions(\\n      customReductions,\\n      state,\\n      action\\n    );\\n\\n    if (!_.isEqual(customAlteredState, state)) {\\n      return customAlteredState;\\n    }\\n\\n    return applyGenericReductions(prefix, reducerGenerics, state, action);\\n  }\\n}\\n\")), mdx(\"p\", null, \"Redux will initially dispatch an empty state, so I need to check for\\nthat and return the initial state if there isn\\u2019t one. Then I need to\\nverify that my custom reductions aren\\u2019t changing the state, and return\\nthe new value if they are. It doesn\\u2019t make perfect sense with the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" use case, but I imagine I\\u2019ll want to have the ability to\\noverride some of the reducers if they\\u2019re grouped together. Finally, I\\nreturn the state after I apply my generic reductions.\"), mdx(\"h3\", {\n    \"id\": \"generic-reducer-application\"\n  }, \"Generic reducer application\"), mdx(\"p\", null, \"For simplicity, I want to iterate over the list of generic reductions in\\norder and return the first one that returns a new state. There\\u2019s a\\npotential for hard to find bugs here if you reuse names, or if you\\ndon\\u2019t know how these generic reductions are being applied, but I don\\u2019t\\nknow how likely that\\u2019s going to be in the wild.\"), mdx(\"p\", null, \"Another downside to this is that I\\u2019m going to be potentially iterating\\nover a lot of states and changing them, so there could be performance\\nissues. I wouldn\\u2019t want to use this for something like\\n\\u201CMOUSE~MOVELEFT~\\u201D or any other actions that might be dispatched\\nfrequently. For something like add, though, which is usually triggered\\nby human actions, it should suffice.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const applyGenericReductions = (prefix, generics, state, action) => {\\n  const newStates = generics\\n    .map(name => {\\n      const reducer = lookupGenericReducer(genericName, prefix);\\n      if (reducer) {\\n        return reducer(state, action);\\n      } else {\\n        throw `Could not find reducer with name: ${genericName}`;\\n      }\\n    })\\n    .filter(newState => !_.isEqual(state, newState));\\n  return newStates[0] || state;\\n};\\n\")), mdx(\"p\", null, \"As an aside, I\\u2019m using the lodash \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isEqual\"), \" method here for deep\\ncomparison. If you\\u2019re not using lodash, you can use whatever deep\\nequals function you like, just note that you can\\u2019t use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"==\"), \" or\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"===\"), \". Those don\\u2019t compare deep equality.\"), mdx(\"p\", null, \"Also note that I haven\\u2019t defined what these custom reducers are going\\nto look like or how I\\u2019m going to retrieve them. I like programming like\\nthis for anything atypical. It\\u2019s slower than writing something that\\n\\u201Cjust works\\u201D, but it forces me into writing code that\\u2019s more\\nconceptually organized. It also removes the temptation to just commit\\nwhatever works and let somebody else worry about figuring out what this\\ncrap does later.\"), mdx(\"h3\", {\n    \"id\": \"the-generic-reducer-structure\"\n  }, \"The Generic Reducer Structure\"), mdx(\"p\", null, \"Before I know how to retrieve one of these reducers, I should figure out\\nhow it\\u2019s going to be look. I know whatever I get back from my lookup\\nfunction needs to be another function that I can call with parameters\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"action\"), \". But in order to dispatch the correct action,\\nI\\u2019ll need to know the prefix that this reducer is going to use.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function addReducer(prefix) {\\n  const types = {\\n    ADD: `${prefix}/ADD`,\\n  };\\n\\n  return (state, action) => {\\n    switch(action.type) {\\n      case types.ADD:\\n        return {\\n          ...state.todos,\\n          [action.payload.id]: ...action.payload,\\n        };\\n      default:\\n        return state;\\n    }\\n  };\\n}\\n\")), mdx(\"p\", null, \"To preserve the state I\\u2019m using a closure, which is just a fancy comp\\nsci word for functions that return functions with stored state. You can\\nuse them like classes to hold state. I generally don\\u2019t care for classes\\nin ES6, but the same thing as a class would be\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"class crudReducer {\\n  constructor(prefix) {\\n    this.types = {\\n      ADD: `${prefix}/ADD`,\\n    };\\n  }\\n\\n  reduce(state, action) {\\n    switch(action.type) {\\n      case types.ADD:\\n        return {\\n          ...state.todos,\\n          [action.payload.id]: ...action.payload,\\n        };\\n      default:\\n        return state;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"One reason I like this less is that I have to invent a name for the\\nmethod to use. I called it reduce because I think that makes sense, but\\nit\\u2019s simpler for me to ignore that detail and just use a function, I\\nthink. I\\u2019m going to proceed using the function version.\"), mdx(\"h3\", {\n    \"id\": \"getting-the-generic-reducers\"\n  }, \"Getting the generic reducers\"), mdx(\"p\", null, \"Now I can turn my attention to getting the reducers. I need a way to\\npass in the prefix and return the reducer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const lookupGenericReducer = (name, prefix) => reducerRegistry[name](prefix);\\n\")), mdx(\"p\", null, \"This is about as brain dead as I can make anything.\"), mdx(\"p\", null, \"If I organize a directory with all your generic reducers, you can export\\nthem all from an index and import them all from one place with something\\nlike\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/genericReducers/index.js\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"export { addReducer } from './addReducer'\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/reducers/todoReducer.js\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import * as reducerRegistry from '../genericReducers';\\n\")), mdx(\"h3\", {\n    \"id\": \"custom-reducer-functions\"\n  }, \"Custom Reducer Functions\"), mdx(\"p\", null, \"I need a way to add additional, non generic, functionality to my\\nreducers. Sometimes I may need to do something more specific than\\n\\u201Cadd\\u201D.\"), mdx(\"p\", null, \"Luckily, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createReducer\"), \" will take a custom reducer function. I can\\nwrite something like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"export const todoReducer = createReducer('todo', {}, ['add'], (state, action) => {\\n  switch (action.type) {\\n    case 'DELETE_TODO':\\n      const newState = { ...state };\\n      delete newState[action.payload.id];\\n      return newState;\\n    default: \\n      return state;\\n  }\\n});\\n\")), mdx(\"p\", null, \"The function in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createReducer\"), \" that will handle that is called\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"applyCustomReductions\"), \". If that function returns a value different\\nthan the current state, I can short circuit and just return the state it\\ngenerates.\"), mdx(\"p\", null, \"The code is similar to the custom reducer code, but it doesn\\u2019t need to\\nhandle multiple functions that change the state.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const applyCustomReductions = (customReductions, initialState, action) => {\\n  if (customReductions) {\\n    return customReductions(initialState, action);\\n  } else {\\n    return initialState;  \\n  }\\n};\\n\")), mdx(\"p\", null, \"Now I have all the pieces to write generic reducer functions. If I want\\na function to update, I just need to write an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updateReducer\"), \" that\\nwill take a prefix, and return a function with parameters \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"action\"), \" and include it in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genericReducers\"), \" argument.\"), mdx(\"h2\", {\n    \"id\": \"downsides\"\n  }, \"Downsides\"), mdx(\"p\", null, \"There are a few weaknesses to this approach.\"), mdx(\"h3\", {\n    \"id\": \"action-types\"\n  }, \"Action Types\"), mdx(\"p\", null, \"First, it relies on convention to determine the types. I have to know\\nthe way that they\\u2019re going to be generated and expect that.\"), mdx(\"p\", null, \"A potential solution to that is to refactor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createReducer\"), \" to return\\nan object with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reducer\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"types\"), \", but I think you\\u2019re starting\\nto betray the name in that case. It\\u2019s not \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"just\"), \" creating a reducer,\\nit\\u2019s generating types. I could create a new function called\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" or something, and reference that, but then I\\u2019ve still\\ngot to know which types are going to be returned in that object to use\\nthem.\"), mdx(\"p\", null, \"For now, I\\u2019m okay just knowing a convention exists. I\\u2019d add a\\nreadme.md in the directory that explained that, and just leave it at\\nthat for now.\"), mdx(\"h3\", {\n    \"id\": \"additional-abstractions\"\n  }, \"Additional Abstractions\"), mdx(\"p\", null, \"This is a more complex system because it includes a new step. There are\\nnew concepts here: generic reducers, implicit action types, etc. I have\\nto anticipate those things and know how to use and debug them. If I come\\nto the codebase, I have to figure out how to add generic functionality\\nwith, let\\u2019s face it, probably no documentation about it.\"), mdx(\"h3\", {\n    \"id\": \"nonstandard-code\"\n  }, \"Nonstandard Code\"), mdx(\"p\", null, \"Maybe worst of all, this is a nonstandard concept. I\\u2019m not going to be\\nable to Google problems I have, because I wrote this code. I\\u2019m going to\\nhave to read the code and figure it out myself. Standard solutions are\\nnice because if you have a problem, chances are somebody else has too.\\nThis is an in-house solution to reducing boilerplate, and that means I\\nhave to read the code.\"), mdx(\"h3\", {\n    \"id\": \"performance\"\n  }, \"Performance\"), mdx(\"p\", null, \"Given that I\\u2019m iterating over multiple potential state changes and - in\\nthis iteration - not short circuiting when I find a change, there\\u2019s a\\npossibility of substantially impacting performance. However, I think the\\ncases where that might be a problem are easily solvable by either not\\nusing this solution, or by passing in custom reductions that will handle\\nthe case right away.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/redux-reducers/","title":"Reducing Boilerplate in Redux","tags":[],"keywords":[],"date":"September 12, 2018"},"previous":null,"next":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"782d36cf-e69a-5f9c-835d-4bf5d513d046"}}}